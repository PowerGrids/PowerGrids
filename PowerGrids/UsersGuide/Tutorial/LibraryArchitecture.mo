within PowerGrids.UsersGuide.Tutorial;

package LibraryArchitecture
  extends Modelica.Icons.Information;
annotation(preferredView = "info",
    Documentation(info = "<html><head></head><body>
<h2>1. Scope of the Library</h2>
<p>The PowerGrids library allows to build electro-mechanical models of balanced, three-phase AC power systems. DC links can be added, described by components of the <a href=\"modelica://Modelica.Electrical.Analog\"> Modelica.Electrical.Analog</a> library. Three-phase AC balanced systems are described by complex phasors, representing the magnitude and phase of voltages and currents with respect to a reference rotating frame. The frequency of the reference frame is propagated through the components of synchronously connected sub-systems by means of overconstrained connectors.</p>


<h2>2. Library Design Principles</h2>

<p>The PowerGrids library is designed around two fundamental principles.</p>
<p>The first one is model-solver separation, also known as declarative modelling style. Component models are described in a way that is as close as possible to their original formulation, as found in textbooks, research papers, or standards, not to the way they will actually be solved at runtime. The most natural formalism is used to describe each model: differential-algebraic equations for synchronous machines, complex phasors for transmission lines and transformers, block diagrams for control systems. The transformation to efficient and numerically robust simulation code is then automatically provided by the tools that compile the original Modelica model into executable code, possibly based on additional declarative information.</p>
<p>One notable case of application of this principle is in the choice of units for the component models. In some cases, e.g. synchronous machine models, per-unit variables are used in textbooks, because they lead to a more compact and readable description of the machine behaviour, if convenient machine-specific base quantities are used. However, the use of per-unit variables at the system level, with some arbitrarily chose base quantities (e.g. 100 MW for power) makes the models hard to understand and potentially error-prone, because of the co-existence of multiple per-unit base quantities across the system model. A better choice in this case is to use SI units consistently across all models, and use the <code>nominal</code> attribute of Modelica variables to provide scaling information, that the tool will automatically and transparently apply when generating the code. </p>
<p>Another application of the declarative modelling principle involves the initialization of the models. One common practice in the field of power systems modelling and simulation is to provide two separate models for each component, one for simulation and one for initialization. In fact, the underlying equations are the same, what is different in those two cases are the choices of input variables, which result into different solution procedures. Writing these pairs of models is inconvenient and potentially prone to inconsistency. In the PowerGrids library, Modelica initial equations are extensively used in order to avoid this unnecessary code duplication and extra work, relying on the simulation tools to solve the equations according to the different causality of the simulation and initialization cases.</p>
<p>Last, but not least, the models in the PowerGrids library are ultimately equivalent to differential-algebraic equations, so they can be coupled to any present or future numerical solver that can handle them, without the need of changing one line of code. This allows to preserve the investment in modelling knowledge, while making it possible to take advantage of future progress in the field of numerical solvers.</p>

<p>The other principle regards the use of advanced Modelica features, such as inheritance. In the PowerGrids library, such advanced features have been used in order to set up a basic modelling framework for individual components, which takes care of potentially critical aspects such as scaling and initialization. This framework, that will be described later in this tutorial, allows experts in power system modelling to write their own models by focusing on the core consitutive equations, without worrying about the more low-level issues which are handled by the basic framework. In this way, ease of development, clarity and maintainability of the code is maximised. Replaceable classes have been employed very parsimoniously: even though they allow to develop very elegant and compact code, the level of abstraction involved results in a fairly steep learning curve, when they are used extensively. Therefore, they have only been used where strictly necessary.</p>

<h2>3. Basic Modelling Framework</h2>

<h3>3.1. Types for Physical Quantities</h3>

<p>The <a href=\"modelica://PowerGrids.Types\">PowerGrids.Types</a> package defines the types for all physical variables, which use SI units, and for non-dimensional per-unit variables. Physical types include a default <code>nominal</code> attribute for proper scaling of variable in the generated simulation code, and default <code>displayUnit</code> attributes, which allow GUIs to provide parameter input and to display simulation results using more convenient units such as kV or MW. Note that the numerical values in the Modelica source code are always in SI units for consistency.
</p><h3>Nominal and reference values</h3><div>The following conventions are used for the names of the parameters that define nominal/reference Voltages and/or Powers:</div><ul dir=\"auto\"><li><b>xxNom:</b> these parameters are always present in the input mask, possibly with some default value (see below the PQ load case). They are used to set the Nominal/rated xx values and as p.u. base. They are also used in the library as <code>nominal</code> attribute for proper scaling of variable in the generated simulation code.<br><u>Exception to this rule:</u> SNom for the Bus component is declared as final SNom = 1, so it is removed from the input mask, since SPu = 0 all the time (no power flow through the port). As a consequence port.P, port.Q, port.PPu, port.QPu etc. will all be zero, as they should, with no divisions by zero.</li>
<li><b>xxRef: </b>these&nbsp;parameters are used to define the behaviour of a components by specifying a reference operating point. In this case, the default value for <b>xxNom</b> is defined in terms of <b>xxRef</b> to avoid double input if one wants to see 1 p.u. at the reference operating point; this can be changed by explicitly inputting some different value for <b>xxNom</b>.</li>
</ul><p>Some example are listed below,</p><p><!--StartFragment--><!--EndFragment--></p><ol dir=\"auto\">
<li><b>Machines (Synchronous and transformer):</b> The user will be asked for xxNom in the input mask, intended as the nominal, or rated values of the machine, <em>but also</em> as the values from which p.u. impedances are computed from the corresponding ohm values, as made it clear from the comment to the parameter. No need of xxRef. For transformer we will have one UNom per winding. xxNom will also be used for scaling, but we don't mention that in the parameter input mask.</li>
<li><b>Lines:</b> same as machines, will be asked for xxNom in the input mask, intended as the nominal, or rated values of the line, <em>but also</em> as the ones from which p.u. impedances are computed from the corresponding ohm values. xxNom values are asked only once and used for both ports, contrary to transformers that have one SNom but two separate UNomA and UNomB. We can give a default value for SNom = UNom^2/CM.abs(Complex(R,X)), which is probably good enough in most cases, but can always be changed.</li>
<li><b>Constant impedance loads described through P and Q:</b> the user will be
 asked in the components' mask for PRefConst, QRefConst and URef (intended as the value at which, from the inputed P and Q, the internal impedances are computed). Regarding UNom and SNom, they will also appear in the input mask, but they will have the defaults UNom = URef and SNom = sqrt(PRefConst^2+ QRefConst^2) already set. One could always change them if you want to see a value of p.u. different from 1 at the reference operating point, which can be different from the nominal one (e.g. you are working at 50% load, so you want to see 0.5 p.u.)</li>
</ol>

<h3>3.2 Connectors</h3>

<p>AC connections are made through connectors, or terminals, of several different types, depending on which models they are used in.</p>
<ul>
<li><a href=\"modelica://PowerGrids.Interfaces.TerminalACVI\">TerminalACVI</a> is the base class for all AC terminals. It contains a complex phase-to-ground voltage phasor and a complex current phasor. According to Modelica connection semantics, when two or more such terminals are connected, connection equations are generated, stating that the voltages are all equal and that the currents, assumed to be positive entering, all sum to zero.</li>
<li><a href=\"modelica://PowerGrids.Interfaces.TerminalACPF\">TerminalACPF</a> is used for the components of the <a href=\"modelica://PowerGrids.Electrical.PowerFlow\">Electrical.PowerFlow</a> package, that are used to build static power flow problems. As the only information required for this purpose is the phasor voltage/current pair, it extends from <a href=\"modelica://PowerGrids.Interfaces.TerminalACVI\">TerminalACVI</a> without adding any other variable.</li>
<li><a href=\"modelica://PowerGrids.Interfaces.TerminalACPF_a\">TerminalACPF_a</a> and <a href=\"modelica://PowerGrids.Interfaces.TerminalACPF_b\">TerminalACPF_b</a> are the same as <a href=\"modelica://PowerGrids.Interfaces.TerminalACPF\">TerminalACPF</a> except for the icons. They are used to graphically differentiate the two terminals of two-port components such as transmission lines or transformers.</li>
<li><a href=\"modelica://PowerGrids.Interfaces.TerminalACBase\">TerminalACBase</a> is the base class for AC terminals of components used for dynamic simulations. As such, it extends from <a href=\"modelica://PowerGrids.Interfaces.TerminalACVI\">TerminalACVI</a>, which provides the voltage/current pair for the dynamic simulation. Additionally, it contains an overdetermined type variable that carries the per-unit frequency of the phasor reference frame, which is used to pass around that information through synchronously connected systems. Finally, it contains a conditional sub-connector of type <a href=\"modelica://PowerGrids.Interfaces.TerminalACPF\">TerminalACPF</a>, which carries the constant voltage/current pair computed by the optional embedded power flow component; this is actually present only if the <code>computePF</code> parameter is set to true.</li>
<li><a href=\"modelica://PowerGrids.Interfaces.TerminalAC\">TerminalAC</a> is the AC terminal for dynamic simulation components. It extends from <a href=\"modelica://PowerGrids.Interfaces.TerminalACBase\">TerminalACBase</a>, adding two input variables for the voltage magnitude and phase start values, plus a suitable icon.</li>
<li><a href=\"modelica://PowerGrids.Interfaces.TerminalAC_a\">TerminalAC_a</a> and <a href=\"modelica://PowerGrids.Interfaces.TerminalAC_b\">TerminalAC_b</a> are the same as <a href=\"modelica://PowerGrids.Interfaces.TerminalACPF\">TerminalAC</a> except for the icons. They are used to graphically differentiate the two terminals of two-port components such as transmission lines or transformers.</li>
<li> <a href=\"modelica://PowerGrids.Interfaces.TerminalACBus\">TerminalACBus</a> is only used for bus components. It extends <a href=\"modelica://PowerGrids.Interfaces.TerminalACBase\">TerminalACBase</a>, adding two output variables for the start values of the bus voltage magnitude and phase, as well as suitable icon.</li>
</ul>

<p>Regarding components for power flow computation, those having only one connector are meant to use <a href=\"modelica://PowerGrids.Interfaces.TerminalACPF\">TerminalACPF</a>, while those with two connectors should use the two variants <a href=\"modelica://PowerGrids.Interfaces.TerminalACPF_a\">TerminalACPF_a</a> and <a href=\"modelica://PowerGrids.Interfaces.TerminalACPF_b\">TerminalACPF_b</a>.</p>

<p>Regarding components for dynamic simulation (except buses), those with one connector should use <a href=\"modelica://PowerGrids.Interfaces.TerminalAC\">TerminalAC</a>, while those with two connectors should use the variants <a href=\"modelica://PowerGrids.Interfaces.TerminalAC_a\">TerminalAC_a</a> and <a href=\"modelica://PowerGrids.Interfaces.TerminalAC_b\">TerminalAC_b</a>. These connectors contain a voltage/current phasor pair, input variables to receive the start values of voltage magnitude and phase from the connected bus component, and an optional embedded power flow sub-connector. Buses should instead use a <a href=\"modelica://PowerGrids.Interfaces.TerminalACBus\">TerminalACBus</a> connector, which provides the voltage start values as outputs.</p>

<p>The following <b>connection rules</b> must be obeyed to build valid PowerGrids models:</p>
<ul>
<li>Power flow components can only be connected to other power flow components. Graphically, <b>yellow connectors can only be connected to other yellow connectors</b>.</li>
<li>Every connection in dynamic models must involve a bus and a non-bus component; it is not possible to connect two non-bus components directly. Graphically, <b>every connection must involve one red connector and one light blue or white connector</b>.</li>
</ul>

<h3>3.3. Handling of the phasor reference frames</h3>

<p>The voltage and current phasors are defined as relative to a rotating frame of reference. For synchronous systems connected to ideal sources with nominal fixed frequency(50 or 60 Hz), all phasors cannot rotate too much with respect to a frame of reference rotating at that frequency; in this case, when the system reaches a steady state, all phasors would be constant. However, if the synchronous system is islanded, it may happen that the system reaches a steady state where all generators rotate at a frequency different from the nominal one. If a fixed frequency reference is used, then all the phasors will be rotating all the time also at steady-state, causing unnecessary shortening of the step size in variable step-size solvers, as well as the need of frequently recomputing the Jacobians. This has a negative impact on the simulation efficiency.</p>

<p>One way to avoid this problem is to pick one generator (usually the largest one in the system) and use a variable-frequency reference frame that rotates at the generator speed. In this way, when the system reaches a steady state, all the phasors in the synchronously connected system will also be constant, allowing variable step-size solvers to increase the time step without incurring in the previously mentioned problems.</p>

<p>A nice, object-oriented way to deal with this problem is to use <a href=\"https://specification.modelica.org/maint/3.6/connectors-and-connections.html#equation-operators-for-overconstrained-connection-based-equation-systems1\">Overconstrained Connectors</a>. In a nutshell, the idea is as follows. The <a href=\"modelica://PowerGrids.Interfaces.TerminalAC\">TerminalAC</a> connector contains a variable <code>omegaRefPu</code> of an overdetermined type, which carries the reference frequency in per unit. When terminals are connected, equations are generated to make the overdetermined variables equal, thus propagating the information through connections. Branch components such as lines or transformers, which contribute to build the synchronous system, contain an equation stating that the reference frequency is the same at the two ports, and a <code>Connections.branch(portA.omegaRefPu, portB.omegaRefPu)</code> statement that explicitly tell the compiler that the two ports belong to the same synchronous systems. So, the compiler can build a connection graph of all synchronously connected terminals, which share the same reference frequency. </p>

<p>For each such connected graph, there must be one and only one tree node that actually sets the frequency. This is achieved by means of the <code>Connections.potentialRoot(port.omegaRefPu, priority)</code> statement, which declares to the compiler that this node can be potentially chosen as root node, with a certain integer priority, which can be computed so that larger generators have a higher likelyhood to be selected. Components that can actually set the reference frequency, such as infinite buses or synchronous generators, must then contain a conditional equation that actually sets the overdetermined variable <code>port.omegaRefPu</code>, activated by the built-in function <code>Connections.isRoot(port.omegaRefPu)</code>, which returns true if the node is selected as the root node of the connection graph.</p>

<p>Summing up, at compile time the Modelica tool builds the connection graphs corresponding to the synchronously connected sub-systems, breaks their loops at connections to form a spanning tree, so that there are no redundant equations, and selects a root node for each connected graph. Then, the corresponding equations in the root and branch components, together with the connection equations, spread the reference frequency signal through the entire synchronously connected system.</p>

<p>This mechanism is already used by other Modelica power system libraries such as <a href=\"modelica://Modelica.Electrical.MultiPhase\">Modelica.Electrical.MultiPhase</a> or <a href=\"modelica://PowerSystems\">PowerSystems</a>. Its only limitation is that the connection graph is static, so it cannot handle the case of synchronous systems that are split in two or more separate sub-systems at runtime, because some critical breakers connecting them are tripped. In this case, the steady-state frequency of the new islanded systems could end up being different, but a single reference frequency will still be used for all of them, resulting in some non-constant phasors at steady-state. An extension to the overconstrained connection mechanism to handle this situation was proposed in <a href=\"https://doi.org/10.3384/ecp19335\">this paper</a>, and may be used in the future if the proposal is accepted in the Modelica Language Specification.

<h3>3.4. Power flows for initialization</h3>

<p>Dynamic power system models in PowerGrids are always initialized in steady-state. The system starts from an equilibrium condition at the nominal frequency (50 or 60 Hz) and the responds to any variation of inputs such as load changes, continuous-time controller set point changes, and discrete controller output changes, e.g., tap changers. Steady-state initialization is specified in the initial equation section of all the components that have continuous-time states, see Section 4 of this Tutorial for more details.</p>

<p>Steady-state initialization problems are expressed by large systems of equations, both linear and nonlinear, that are solved using iterative Newton-Raphson algorithms. As discussed by <a href=\"http://dx.doi.org/10.1016/j.amc.2021.125991\">Casella and Bachmann 2021</a> (see <a href=\"https://arxiv.org/abs/1911.12433\">here</a> for an open access preprint of the same paper), achieving safe convergence of such algorithms requires the variables appearing nonlinearly in the system (and only them!) to be given a good initial guess, close enough to the solution. This can be accomplished in Modelica by conveniently setting their <i>start</i> attribute.</p>

<p>The convergence of the initialiation problem is crucial for the actual usability of the library, which was designed with this issue in mind. Electrical components extending <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortAC\">OnePortAC</a> define four parameters: <code>UStart</code>, <code>UPhaseStart</code>, <code>PStart</code>, and <code>QStart</code></li>, which hold initial guess values for the voltage magnitude and phase and for the active and reactive power flows through the port; similarly, <code>UStart_a</code>, <code>UStart_b</code> etc. are defined in <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortAC\">TwoPortAC</a>. Based on these parameters, start values (i.e.,  guess values for the steady-state initialization problem) for all other nonlinear variables in derived components can be computed. The idea is that once these parameters are set to values that are close enough to the actual initial steady-state solution, the convergence of the initialization problem is guaranteed.</p>

<p>The components in the <a href=\"modelica://PowerGrids.Electrical.Buses\">Buses</a> package propagate their <code>UStart</code> and <code>UPhaseStart</code> port parameter values on their <a href=\"modelica://PowerGrids.Interfaces.TerminalACBus\">TerminalACBus</a> connector, which is shown in red in diagrams. All other components get their values from connectors extending <a href=\"modelica://PowerGrids.Interfaces.TerminalACBase\">TerminalACBase</a> (shown in light blue or white in diagrams) that have input variables from them, and get them from the bus components. As a consequence, as already noted in Section 3.2, it is not possible to directly connect two non-bus components together; non-bus components must be always connected to a bus component.</p>

<p>There are two different ways to set these port start values, which are selected by the <code>computePF</code> parameter of the system object.</p>

<p>The default choice (true) activates the embedded power flow components inside each dynamic component, which are connected in the same way as the dynamic components thanks to the structured <a href=\"modelica://PowerGrids.Interfaces.TerminalACBase\">TerminalACBase</a> connectors. In this way, the power flow model corresponding to the dynamic simulation model is automatically built and used to automatically set the power flow guess value parameters via their default expressions, <i>without the need of any manual intervention by the end user</i>. This power flow model has a much simpler structure than the steady-state initialization problem of the dynamic model, so it is likely to converge with a trivial initial guess, whereby all voltages are given a guess value of 1 p.u. with zero degrees phase, and all currents and power flows are given an initial guess of zero.</p>

<p> Note that this embedded power flow is an approximate one; for example, PQ load models do not take into account the dependency of the power flow on the voltage level. This is meant to make the power flow model as simple and robust as possible, and yet can provide an initial guess which is close enough to the actual initial steady state to guarantee the convergence of the steady-state initialization problem for the dynamic system. This of course assumes that the constant power flows used in PQ and PV buses, set by parameters <code>PStart</code> and <code>QStart</code> in the corresponding generator and load components, are consistent with the actual initial input values provided to them.</p>

<p>The embedded power flow initialization strategy works according to this principle: when the embedded power flow components are activated, the default values of the <code>UStart</code>, <code>UPhaseStart</code>, <code>PStart</code> and <code>QStart</code> parameters depend on the results of the system power flow, that are sampled at initialization. Therefore, standard dependency analysis applied by Modelica tools to the overall model automatically sorts the computational sequence when solving the initialization problem:</p>
<ul>
<li>The embedded power flow is solved up front</li>
<li>The voltage and power flow values at each component port are sampled and used to compute the start attributes for the steady-state initialization of the dynamic model</li>
<li>The initialization problem of the dynamic model is solved, using the results of the embedded power flow as initial guess. This also means that an approximated power flow is good enough, since iterative Newton solvers converge quickly and without problems if initialized close enough to the solution.</li>
</ul>
<p>What is nice here is that there is no need to explicitly program this sequence of actions in the Modelica model - the Modelica tool figures this out automatically, based on the structural properties of the underlying equation-based model.</p>

<p>This default choice, which is a unique feature of the PowerGrids library, compared to its Modelica power system library competitors, is meant to be good enough to automatically provide the initial power flow to simple enough system models, such as those used in a teaching context. The idea is that one can build textbook examples quicly by using the drag-and-drop metaphor, and immediately get them to run. This approach has been validated successfully on the well-known IEEE 14-bus benchmark.</p>

<p>Alternatively, one can de-activate the embedded power flow components by setting <code>computePF = false</code> in the system object. In this case, it is necessary to explicitly set the <code>UStart</code>, <code>UPhaseStart</code> parameters in all the buses (corresponding to nodes in netlists), and the <code>PStart</code>, <code>QStart</code> parameters in all other components (corresponding to branches in the netlist). This approach can be followed in the context of medium- and large-scale system modelling, e.g. by transmission system operators, whereby the Modelica model of the system is automatically generated from netlists or databases, and the initial power flow data is provided by external power flow computation and optimization codes.</p>

<p>This choice makes PowerGrids extremely flexible and usable both in a limited complexity context such as classroom usage, as well as for professional and research use, dealing with large system models.</p>
</ul>

<h3>3.5. AC Ports</h3>

<p>The <a href=\"modelica://PowerGrids.Electrical.BaseClasses.PortAC\">PowerGrids.Electrical.BaseClasses.PortAC</a> model is the fundamental component to interface AC models with the outside world via a three-phase balanced AC system. The <code>PortAC</code> model contains all the useful representations of the quantites found at a component port, as well as the equations relating them: phase-to-phase and phase-to-ground voltage in Cartesian and polar coordinates, line currents in Cartesian and polar coordinates, active and reactive power flows, both in SI units and per-unit, referred to local base power SBase and voltage UBase. Each of these pre-defined quantities can be directly used to formulate the equations of the component, without the need of re-defining them each and every time a new model is written.</p>

<p>Since the port variables are often the unknowns of the initialization problem, their start attributes must be set to provide appropriate initial guess values for iterative implicit equation solvers. The <code>PortAC</code> model takes care of this, provided that its parameters <code>PStart</code>, <code>QStart</code>, <code>UStart</code>, and <code>UPhaseStart</code> are correctly set to the values provided by the initial power flow calculation.</p>

<h3>3.6. Base classes for components with one and two AC ports</h3>

<p>The <a href=\"modelica://PowerGrids.Electrical.BaseClasses\">Electrical.BaseClasses</a> package contains the infrastructure to define components with one and two ports, both for static power flow and for dynamic simulations. These base models allows a modeller to define a new model by extending them and simply adding the model-specific equations, using the relevant port variables, e.g. current, voltage, per-unit current, per-unit voltage, active power, reactive power, etc. Everything else (connectors, definition of port quantities, initialization, scaling, optional embedded power flow) is already defined once and for all in the base classe.</p>
<ul>
<li>The <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortACVI\">OnePortACVI</a> partial model provide the base framework for a <i>naked</i> one-port AC model, thus only relating voltage and currents but without any specific reference at being meant for power flow or for dynamic simulation. This base class defines the common items for both power flow and dynamic simulation models with one port: the AC connector <code>terminalAC</code>, the AC port <code>port</code>, the nominal voltage <code>UNom</code> and apparent power <code>SNom</code> parameters, and some parameters flag to activate optional computations.</li>
<li>The <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortACVI\">TwoPortACVI</a> partial model</li> is similar to the previous one, but defines two connectors <code>terminalAC_a</code> and <code>terminalAC_a</code>and two corresponding ports <code>portA</code> and <code>portB</code>.</li>
<li>The <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortACPF\">OnePortACPF</a> and <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortACPF\">TwoPortACPF</a> partial models extend from the two previous ones, specializing them as base classes for power flow models; this basically just requires to redeclare the connector type, to set some start attributes of the connector variables, and to suitably link the connector variables to the port variables.</li>
<li>The <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortAC\">OnePortAC</a> partial model also extends from the <i>naked</i> <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortACVI\">OnePortACVI</a> base model, specializing it as base class for dynamic simulation. This is a lot more involved, as it requires to 
<ul>
<li>redeclare the connector type</li>
<li>set some start attributes of the connector variables</li>
<li>link the connector variables to the port variables</li>
<li>define an outer <code>systemPowerGrids</code> object with system-level settings</li>
<li>define parameters PStart and QStart for the start values of the power flow</li>
<li>define a conditional replaceable embedded power flow component <code>componentPF</code></li>
<li>Define conditional initial equations that compute start values <code>PStartPF</code> and <code>QStartPF</code> using the embedded power flow component</li>
<li>Define initial equations for the different types of steady-state initialization, based on the system settings</li>
<li>Set up the dynamic visualization of power flow values on the system diagram</li>
</ul>
Luckily, this is all done for you once and for all in the base class, so you don't have to worry too much about it.</li>
<li>The <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortACdqPU\">OnePortACdqPU</a> extends from <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortAC\">OnePortAC<a>, adding the definitions of per-unit direct and quadrature currents and voltages and defining Park's transformation equations for the rotor current and voltages; this is the base class for all rotating machinery components.</li>
<li>The <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortACBus\">OnePortACBus</a> partial model extends from the <i>naked</i> <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortACVI\">OnePortACVI</a> model, providing the specialized equations for buses, in particular putting the start values for voltage magnitude and phase on the output variables of its AC port. 
<li>The <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortACBase\">TwoPortACBase</a> and <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortAC\">TwoPortAC</a> play the same role of <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortAC\">OnePortAC</a> for two-port components, so they can be used to derive dynamic models that have two ports instead of one. The <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortAC\">TwoPortAC</a> base class is meant for two-port components that enforce a synchronous connection between them, such as transmission lines or transformers; the <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortACBase\">TwoPortACBase</a> class instead doesn't do that, so it can be used, e.g., to model AC-AC converters that link two independent synchronous networks.</li>
</ul> 

<p>The base classes <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortAC\">OnePortAC</a>, <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortACBus\">OnePortACBus</a>, <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortACdqPU\">OnePortACdqPU</a>, <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortACBase\">TwoPortACBase</a>, and <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortAC\">TwoPortAC</a> all implement the embedded power flow mechanism discussed in Section 3.4. They define a Boolean parameter <code>hasSubPF</code> to indicate whether the component contains other components internally that have their own embedded power flows.</p>
<p>In the default case <code>hasSubPF = false</code>, there are no such submodels, so the embedded power flow model (if activated) has to be redeclared to a concrete power flow component from <a href=\"modelica://PowerGrids.Electrical.PowerFlow\">Electrical.PowerFlow</a>, that will be used to build the system power flow model. In case <code>hasSubPF</code> is set to true when extending the base class, this indicates that the sub-models implementing this component already provide their own embedded power flow components, so there is no need to instantiate an embedded power flow component for the model in question.</p>
<p>The <code>hasSubPF</code> is a structural property of the extended component, that cannot be changed when the model is instantiated. Therefore, it is recommended to declare it as <code>final</code> when extending the base class, so that it doesn't show up in the parameter input dialog of the extended component.</p>

<p>Additionally, the <a href=\"modelica://PowerGrids.Electrical.Branches.BaseClasses.PiNetwork\">PowerGrids.Electrical.Branches.BaseClasses.PiNetwork</a> model extends <code>TwoPortAC</code> and provides the equations for a generic pi-circuit with a series admittance, two shunt admittances, and an ideal transformer. This class can be then easily specialized to a range of linear branch components, e.g., transformers and transmission lines, by extending it and specifying the values of the admittances and transformer ratios, that can be constant values (e.g. a transformer ratio of 1 for transmission lines), user-defined parameters, or time-varying quantities, see all the components in the  <a href=\"modelica://PowerGrids.Electrical.Branches\">PowerGrids.Electrical.Branches</a> package.</p>

<p>The base class discussed above are <i>partial</i> models, meaning they have more variables than equations. This is done on purpose, because the base classes are generic, and the missing equations are the ones that will qualify the specific component that can be obtained by extending them. More specifically, we can define the number <code>N</code> of degrees of freedom of a partial model as the difference between its number of unknowns and its number of equations. It is then  possible to derive complete models by extending from it and adding <code>M >= 0</code> extra variables and <code>N + M</code> extra equations.</p>
<p> All the OnePort base models (except OnePortACdqPU)  have 2 degrees of freedom, conceptualy corresponding to the real and imaginary parts of a generalized relationship between their port voltage and port current. OnePortACdqPU has one extra degree of freedom corresponding to the rotor angle <code>theta</code>. The TwoPort models have 4 degrees of freedom, 2 for each port. Note that the models that extend them do not necessarily need to provide a direct relationship beween the port voltage and current - they just need to provide two more equations than the number of extra variables they define. Of course the resulting set of equations must be well posed and have a solution, for the model to be valid.</p>

<h3>3.7. Basic control blocks</h3>

<p>Controllers such as turbine governors, automatic voltage controllers and power system stabilizers are usually specified in terms of block diagrams, e.g. in the well-known IEEE 421.5 standard. The basic building blocks are provided in package <a href=\"modelica://PowerGrids.Controls\">PowerGrids.Control</a>; as their implementation

</p><h2>4. Initialization</h2>

<p>Dynamic system models built with the <code>PowerGrids</code> library must be initialized in steady-state. Doing so requires in general the solution of implicit nonlinear systems of equations, using iterative Newton-type solvers.  The analysis reported in <a href=\"https://arxiv.org/abs/1911.12433\">Casella, Bachmann 2019</a>, in particular Criterion 1, reveals that in order to obtain a quick convergence of Newton's algorithm to the desired solution, only the variables influencing the system Jacobian, i.e., the variables appearing in a nonlinear fashion in at least one equation of the system, must be given a good initial guess. </p>
<p>The library was thus designed to compute all the required initial guesses by means of suitable initial equations, which require the knowledge of the results of a power flow computation, i.e., the active and reactive power flows, as well as the voltage magnitude and phase, at each component port in the system. For small systems, this power flow can be computed by building the corresponding power flow model using components from the <a href=\"modelica://PowerGrids.Electrical.PowerFlow\">PowerGrids.Electrical.PowerFlow</a> and by simulating it with the Modelica tool. For larger systems, and/or systems including complex wide-area controllers, the results obtained by any external power flow computation code can be used.</p>

<p>Note that, according to the previously mentioned convergence criterion, providing correct start values at the ports <i>is only required for those components that contain nonlinear equations</i>, e.g., synchronous machines or PQ loads. Components containing only linear equations, such as buses, transmission lines, transformers (without saturations), capacitor banks, do not require accurate initial values to achieve convergence of the steady-state initialization problem. Hence, particularly if you build the system model manually through a GUI, you can safely keep their default values and not bother to provide them the results of the power flow computation.</p>

The library was designed to initialize the system model according to three different problem set-ups, which can be selected by a parameter in the <code>System</code> object of the model and are discussed in the following sub-sections. The correct initial equations are triggered within each component based on the parameter choice made in the <code>System</code> object.

<h3>4.1. Global steady-state, fixed set points</h3>

<p>In this case a global steady-state problem is solved, assuming the set points of governors and AVRs to be known, or possibly assuming that the excitation voltage and active power signal are directly provided to the synchronous machine model. The system is initialized at the nominal frequency of 50 Hz (or 60 Hz if so selected in the <code>System</code> object preferences). The reference bus of the model plays the role of slack node, prescribing the initial voltage and providing the required (hopefully small) active and reactive power supply to balance the system.</p>

<h3>4.2. Global steady-state, fixed power flows</h3>

<p>In this case, the guess values at the ports coming from the power flow are tentatively prescribed, causing the Modelica tool to back-compute the offsets for the governor and AVR setpoints, which are provided by suitable <a href=\"modelica://PowerGrids.Controls.FreeOffset\">FreeOffset</a> blocks activated by this initialization option. In case the controllers cannot provide the required output values corresponding to the power flow, because of control action saturations, then a conventional value for the setpoint is computed, to guarantee a certain amount of oversaturation of the manipulated variable (e.g. 10%).</p>

<h3>4.2. Local steady-state, fixed power flows</h3>

<p>In the two previous cases, a global steady-state initialization problem needs to be solved, involving the generators, transformers, grid, and load simultaneously. In those cases, the port voltage and current and the connector voltage and current at each generator port are identically equal.</p>
<p>However, in case discrete controllers (e.g. tap changers) are present in the system, this problem may be hard or impossible to solve by means of general-purpose solvers as those that are employed by Modelica tools, particularly for very large systems.</p>
<p>In this case, the option discussed in this sub-section triggers a special configuration of the generator ports during the initialization phase, whereby there is no direct connection between the port variables and the connector variables; conversely, the connector (which is attached to the grid) is subject to prescribed P,Q flows based on the power flow computation results, while all four degrees of freedom at the port side towards the generator (active and reactive power, voltage magnitude and angle) are prescribed at the power flow values, see the initial equations of <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortAC\">OnePortAC</a> </p>
<p> The two additional initial conditions prescribed in this case are again required to compute the initial offsets of the governor and AVR setpoints. However, contrary to the previous case, the machine models are not interacting with each other through the connection to the grid, so the Modelica tool will be able to sort out the initial equations accordingly and solve the backward initialization problem for each machine separately, while the rest of the grid model is solved by prescribing the P,Q values of the power flow, which is un-problematic. This makes the solution of the initialization problem more robust, since it is split in a large number of smaller problems. Notice however that if the supplied power flow values are not exactly consistent with the steady-state behaviour of the dynamic system model, the simulation will not start in a (global) steady state, but there will be a relaxation transient at the beginning of the simulation.</p>

<h3>4.3. Use of homotopy for the initialization</h3>

<p>The physical component models are set up in order to provide a suitable initial guess (start value) for variables appearing nonlinearly in the equations - this is reasonably easy to achieve, as most useful values are already computed in the <code>port</code> model, and the few extra ones may be computed by implicit initial equations that mimick the actual equations of the component, see e.g., the initial equations in the <a href=\"modelica://PowerGrids.Electrical.Machines.SynchronousMachine4WindingsInternalParameters\">PowerGrids.Electrical.Machines.SynchronousMachine4WindingsInternalParameters</a> model.</p>
<p>On the other hand, setting up proper initial guesses for the variables appearing nonlinearly in controller models (e.g. governors, AVRs, PSSs) is highly inconvenient, because those variables are spread among the various blocks making up the controller, and it is often not exactly clear who they may be. </p>
<p>The solution in this case is the use of a homotopy transformation (see the paper by <a href=\"https://dx.doi.org/10.3384/ecp1106375\">Sielemann et al. 2011</a>), whereby a simplified version of the equations is first solved, which is then continuously morphed into the actual one. In the case of controllers, they are usually linear, except for the presence of saturations. The simplified model solved at the beginning of the homotopy tranformation ignores the saturations, making the controller models fully linear and hence avoiding the need of providing any initial guess for their unknowns, as discussed previously. It is then essential that all blocks with saturations employed in control systems have their saturations initially disabled when the homotopy transformation is performed, for the whole initialization procedure to succeed.</p>

<h3>4.4. System object</h3>

Each system model needs to add an <code>inner</code> instance of the <code>System</code> object named <code>system</code> (you can get it in any Modelica GUI by simply dragging the system object into the top-level system diagram). The system objects holds system-wide defaults, e.g., the nominal frequency or the initialization option, and provides a frequency reference to all synchronous machines. All components can access the variables and parameters of the system object via the inner/outer mechanism, without the need of explicitly establishing connections.<p></p>

<h2>5. Defining new components</h2>

<p>All the components in the <a href=\"modelica://PowerGrids.Electrical\">Electrical</a> package are built by extending the base models described in the previous section. However, some of them are a bit involved, because their code is further spread into several classes, with the goal of managing model variants while avoiding unnecessary code duplications, that hamper the maintainability of the library. This can make them a bit hard to understand for beginners, and not the ideal entry point to learn how use base classes to develop new models in PowerGrids.</p>

<p>For this reason, some simple examples are discussed in this section, to demonstrate how to use the base classes described in the previous section, without any further use of inheritance. Once you get familiar with these concepts, you may use the actual models of the library as templates for handling model variants without code duplications.</p>

<p>Our goal here is thus to build a simple system with one rotating generator, one transmission line, and one load, writing the components from scratch, but exploiting the previously introduced base classes.</p>

<h3> 5.1 Load model</h3>

<p>The definition of the <a href=\"modelica://PowerGrids.Examples.Tutorial.HowToBuild.Components.LoadPQ\">LoadPQ</a> model definition is straightforward. The model extends <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortAC\">OnePortAC</a>. It adds two input connectors P and Q, providing the values for the active and reactive power consumption as external inputs, which can be considered to be known in terms of degrees-of-freedom analysis, since they will be connected to known signal sources. Since the base model has 2 degrees of freedom and we are not adding any unknowns, we just need to write two Real equations. In this case, we simply set the active and reactive power through the port <code>port.P</code> and <code>port.Q</code>, which are already defined in the base class, to be equal to the two inputs <code>P</code> and <code>Q</code>. That's basically it. </p>
<p>Additionally, one has to finalize the configuration of the base class <code>OnePortAC</code> when extending it by redeclaring its power flow component <code>componentPF</code> to be a <code>PQBus</code> and setting its parameters <code>SNom</code>, <code>UNom</code>, <code>P</code> and <code>Q</code> appropriately, based on the parameters defined in the <code>LoadPQ</code> model. Note that the values gien to the <code>PStart</code> and <code>Qstart</code> parameters of <code>LoadPQ</code>, which are used to parameterize the embedded power flow component, must be consistent with the initial values of the signals supplied to the <code>P</code> and <code>Q</code> input connectors, for the initialization to be successful.</p>
<p>Finally, the <code>hasSubPF</code> parameter is declared to be final (i.e., not further changeable), so it doesn't show up in the parameter input dialog of <code>LoadPQ</code>.</p>

<h3>5.2. Transmission line model</h3>

<p>The second model we build is a simple transmission line with a series impedance only, defined by a series resistance <code>R</code> and a series reactance <code>X</code>. In this case, the base class to be used to derive the dynamic model is <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortAC\">TwoPortAC</a>, which is meant for two-port AC dynamic components that establish a synchronous connection between their two ports.</p>

<p>The <a href=\"modelica://PowerGrids.Examples.Tutorial.HowToBuild.Components.TransmissionLine\">TransmissionLine</a> model thus defines three user-supplied parameters <code>UNom</code>, <code>R</code>, and <code>X</code>, plus a non-user-supplied final parameter <code>Z</code>, computed from the supplied resistance and reactance, and used to define the parameters in the base class <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortAC\">TwoPortAC</a>. The embedded power flow component is redeclared to be <a href=\"modelica://PowerGrids.Electrical.PowerFlow.LineConstantImpedancePF\">LineConstantImpedancePF</a>, which is also parameterized using the previously mentioned parameters defined in <a href=\"modelica://PowerGrids.Examples.Tutorial.HowToBuild.Components.TransmissionLine\">TransmissionLine</a>. As usual when extending from a OnePortAC or TwoPortAC base class, the <code>hasSubPF</code> parameter is declared to be final (i.e., not further changeable), so it doesn't show up in the parameter input dialog of <code>LoadPQ</code>.</p></p>

<p>Five local complex variables <code>vA</code>, <code>vB</code>, <code>iA</code>, <code>iB</code>, and <code>vZ</code> are defined, the first four being aliases of the port phase-to-ground voltages and current, the last being the phase-to-ground voltage difference between port B and port A. Regarding their <i>nominal</i> attributes for scaling, there is no need to explicitly set it for the four alias variables, since Modelica tools should be able to automatically infer it to be equal to the nominal attribute of the corresponding port variable, which is set in the base classes; it is instead recommended to set it for the variable <code>vZ</code>, which otherwise would be left without any scaling information. Regarding their <i>start</i> attributes, it is not necessary to set them because these variables are only appearing linearly in the model equations.</p>

<p>Overall, the base class <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortAC\">TwoPortAC</a> has four real degrees of freedom, two per each port. The complex variables <code>vA</code>, <code>vB</code>, <code>iA</code>, <code>iB</code> are declared with a binding equation, so they don't alter the variables/equations balance. The variable <code>vZ</code> instead adds two extra real degrees of freedom, one for its real part and one for its imaginary part, bringing the number of real degrees of freedom to six.</p>

<p>Having set the stage, thanks to the base classes, we can write the model-specific equations, possibly using both the locally defined variables, but also the variables defined in the base class. In this case, three complex equations (corresponding to six real equations) must be written: one defines <code>vZ</code> as the voltage difference between the two ports, one states that the sum of the two entering currents is zero (there are no shunt impedeances in this model), and the last one is the generalized Ohm's law.</p>


<h3>5.3. Generator model</h3>

<p>Finally, we write the <a href=\"modelica://PowerGrids.Examples.Tutorial.HowToBuild.Components.SimpleGenerator\">SimpleGenerator</a> model of an idealized synchronous generator, where the stator circuit has a per-unit resistance <code>rPu</code> and the rotor induces an e.m.f. of 1 pu on the direct axis; the generator is assumd to have unit mechanical and electrical efficiency for simplicity.</p>
<p>To this purpose, we can extend the <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortACdqPU\">OnePortACdqPU</a> model, which has 3 degrees of freedom, and defines the per-unit direct and quadrature stator voltages <code>udPu</code> and <code>uqPu</code> and currents <code>idPu</code> and <code>iqPu</code>, as well as the rotor angle <code>theta</code>. We also redeclare the <code>componentPF</code> embedded power flow model to be <a href=\"modelica://PowerGrids.Electrical.PowerFlow.PVBus\">PowerFlow.PVBus</a>, as appropriate to represent a generator with essentially fixed voltage. We then define several parameters: <code>UPF</code> and <code>PPF</code> to provide the values of the phase-to-phase voltage magnitude and active power input of the embedded power flow PV generator, the generator time constant <code>H</code> to be used in the swing equation, and the per-unit stator resistance <code>rPu</code>. Finally, we define an additional variable, the per-unit angular speed <code>omegaPu</code>.</p>
<p>Having added one more variable on top of the 3 degrees of freedom, we need to write four real equations to obtain a balance model. The first two are the swing equations, the other two are the per-unit direct and quadrature voltage balances.</p>
<p>We then deal with the propagation of the reference frame information. The generator can potentially be the source of that information, so we declare< <code>Connections.potentialRoot(terminalAC.omegaRefPu)</code>. In case it actually is selected as root, we must add an equation to set <code>terminalAC.omegaRefPU</code> to be equal to the per-unit frequency <code>omegaPu</code> of the generator itself. Otherwise, that information will be propagated to the generator from outside the component.</p>
<p>Finally, since we introduced two state variables in the model (<code>theta</code> and <code>omegaPu</code>), we need to provide two initial equations to enforce initial steady-state conditions. The first initial equation sets the per-unit angular velocity at 1 p.u., since the system is always initialized at the nominal frequency. The other initial equation states that the derivative of the angular velocity is zero, which corresponds to stating that the generator mechanical input power <code>Pm</code> and the active power entering the generator port <code>port.P</code> must balance to zero; this will indirectly determine the steady-state angle theta of the generator, with respect to reference zero angle of the infinite bus.</p>

<h3>5.4. Component testing</h3>

<p>Before using newly developed components to simulate complex systems, it is always a good practice to first test them in elementary test cases where their behaviour can be computed manually, to verify that the implementation is correct.</p>

<p>The LoadPQ model is tested in <a href=\"modelica://PowerGrids.Examples.Tutorial.HowToBuild.Examples.TestLoadPQ\">TestLoadPQ</a>, by connecting it to an infinite bus prescribing the voltage at its port. Two loads are tested, one with purely active power consumption, the other with purely reactive power consumption. In both cases the component simulates successfully, and the computed power and current flows are as expected.</p>

<p>The TransmissionLine model is tested in <a href=\"modelica://PowerGrids.Examples.Tutorial.HowToBuild.Examples.TestTransmissionLine\">TestTransmissionLine</a>. The line is connected to two infinite buses. In the first case, the two buses have the same phase and a voltage difference of 0.1 kV while the line is purely resistive and has a resistance of 1 Ohm. In the second case, the two buses have the same voltage and a phase difference of 5.7 degrees, or about 0.1 radians. In both cases, the current and power flows are as expected; note that the bus voltages are expressed as phase-to-phase, so there are some sqrt(3) factors involved when computing the current.</p>

<p>The Generator model is tested in open circuit conditions. It still needs to be connected to a reference bus for proper steady-state initialization. At initialization, the mechanical power input is zero and the generator is at equilibrium, rotating at constant nominal frequency. Since it is selected as root node of the overconstrained connection graph, its rotating frame of reference rotates at the same frequency as the rotor, so the voltage at its port is fixed at one p.u. with zero phase. At time = 1, the mechanical power input is increased by 10 &perc of the nominal power of the generator. As a consequence, after <code>2*H</code> seconds, the frequency will have increased by 0.1 p.u.</p>

<h3>5.5. System model</h3>

<p>To test the components we have just written, we can build the <a href=\"modelica://PowerGrids.Examples.Tutorial.HowToBuild.Examples.SimpleGrid\">SimpleGrid</a> model, where we connect the generator to a load, and also to an infinite bus through a transmission line.</p>
<p>At time = 1 we increase the active power consumption of the load; this causes an imbalance in the power balance of the swing equations and triggers electro-mechanical oscillations between the machine rotor and the infinite bus, which are not significantly damped due to the absence of damping mechanisms such as damper windings in this very simple model.</p>

<h3><a name=\"DualUse\">5.6. Power flow models and dual use VI models</a></h3>

Normally it is not required to write new power flow component models, as in most cases the components provided in the <a href=\"modelica://PowerGrids.Electrical.PowerFlow\">Electrical.PowerFlow </a> library already cover most cases. In case one wants to write a new power flow model, the models already contained in that package can be used as a source of inspiration. The bottom line is, one inherits from <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortACPF\">OnePortACPF</a> or <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortACPF\">TwoPortACPF</a> instead of <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortAC\">OnePortAC</a> or <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortAC\">TwoPortAC</a>. Note that power flow models have no provisions for computing start values (trivial defaults are used) and do not need the overconstraind connectors to propagate the reference frequency, so the base classes are much less involved.</p>

<p>In some cases, the same <i>naked</i> VI electrical model can be used both for power flow and dynamic modelling, e.g. in the case of generic linear pi-circuits that can represent transmission lines and transformers. In this case it is possible to avoid duplicating the code by writing a base model that extends <a href=\"modelica://PowerGrids.Electrical.BaseClasses.OnePortACVI\">OnePortACVI</a> and <a href=\"modelica://PowerGrids.Electrical.BaseClasses.TwoPortACVI\">TwoPortACVI</a>, using that framework to write the naked model equations once and for all. It is then possible to extend the model in order to adapt it to be used for both power flow an dynamic simulation uses; this requires some clever redeclaration and multiple inheritance.</p>
<p>As an example, you can check how the base naked model <a href=\"modelica://PowerGrids.Electrical.BaseComponents.PiNetworkVI\">PiNetworkVI</a> is first defined, containing the equations of a generic pi-network with one series impedance, two shunt admittances, and one ideal tranformer. This model is then specialized to the models <a href=\"modelica://PowerGrids.Electrical.BaseComponents.LineConstantImpedanceVI\">LineConstantImpedanceVI</a>, <a href=\"modelica://PowerGrids.Electrical.BaseComponents.LineConstantImpedanceWithBreakersVI\">LineConstantImpedanceWithBreakersVI</a>, <a href=\"modelica://PowerGrids.Electrical.BaseComponents.TransformerFixedRatioVI\">TransformerFixedRatioVI</a>, and <a href=\"modelica://PowerGrids.Electrical.BaseComponents.TransformerFixedRatioWithBreakerVI\">TransformerFixedRatioWithBreakerVI</a>, by setting the impedance and transformer ratio parameters and possibly by adding further equations. Then, the power flow models, e.g., <a href=\"modelica://PowerGrids.Electrical.PowerFlow.LineConstantImpedancePF\">LineConstantImpedancePF</a> and the dynamic models, e.g., <a href=\"modelica://PowerGrids.Electrical.Branches.LineConstantImpedance\">LineConstantImpedance</a> are derived from the VI model by means of multiple inheritance, without repeating the model equations. This architecture is not trivial, and it's not mandatory - there are no strict rules against code duplication. On the other hand, it allows to avoid a massive amount of code repetitions and makes the development and maintenance of the whole family of models a lot easier.</p>
</body></html>"));
end LibraryArchitecture;
